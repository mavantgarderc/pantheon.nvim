local M = {}

M.apply = function(theme)
  local c = theme.colors

  vim.g.terminal_color_0 = c.base00
  vim.g.terminal_color_1 = c.base08
  vim.g.terminal_color_2 = c.base0B
  vim.g.terminal_color_3 = c.base0A
  vim.g.terminal_color_4 = c.base0D
  vim.g.terminal_color_5 = c.base0E
  vim.g.terminal_color_6 = c.base0C
  vim.g.terminal_color_7 = c.base05
  vim.g.terminal_color_8 = c.base03
  vim.g.terminal_color_9 = c.base08
  vim.g.terminal_color_10 = c.base0B
  vim.g.terminal_color_11 = c.base0A
  vim.g.terminal_color_12 = c.base0D
  vim.g.terminal_color_13 = c.base0E
  vim.g.terminal_color_14 = c.base0C
  vim.g.terminal_color_15 = c.base07
  vim.g.terminal_color_background = c.base00
  vim.g.terminal_color_foreground = c.base05
end

M.export_ghostty_toml = function(theme)
  local c = theme.colors

  local lines = {
    "# " .. theme.name,
    "# Generated by Pantheon.nvim",
    "# " .. os.date("%Y-%m-%d %H:%M:%S"),
    "",
    "palette = 0=" .. c.base00,
    "palette = 1=" .. c.base08,
    "palette = 2=" .. c.base0B,
    "palette = 3=" .. c.base0A,
    "palette = 4=" .. c.base0D,
    "palette = 5=" .. c.base0E,
    "palette = 6=" .. c.base0C,
    "palette = 7=" .. c.base05,
    "palette = 8=" .. c.base03,
    "palette = 9=" .. c.base08,
    "palette = 10=" .. c.base0B,
    "palette = 11=" .. c.base0A,
    "palette = 12=" .. c.base0D,
    "palette = 13=" .. c.base0E,
    "palette = 14=" .. c.base0C,
    "palette = 15=" .. c.base07,
    "background = " .. c.base00,
    "foreground = " .. c.base05,
    "cursor-color = " .. c.base05,
    "cursor-text = " .. c.base00,
    "selection-background = " .. c.base02,
    "selection-foreground = " .. c.base05,
  }

  return table.concat(lines, "\n")
end

M.write_ghostty_config = function(theme, config_path)
  local content = M.export_ghostty_toml(theme)

  config_path = vim.fn.expand(config_path)

  local dir = vim.fn.fnamemodify(config_path, ":h")
  vim.fn.mkdir(dir, "p")

  local file = io.open(config_path, "w")
  if file then
    file:write(content)
    file:close()
    return true
  else
    vim.notify("Pantheon: Failed to write " .. config_path, vim.log.levels.ERROR)
    return false
  end
end

M.reload_ghostty = function()
  -- Ghostty supports reloading config via SIGUSR2 (available in recent versions)
  -- Try pgrep and kill -USR2
  local result = vim.fn.system("pgrep -x ghostty | xargs -r kill -USR2")
  if vim.v.shell_error == 0 then return true end

  -- Fallback to pkill
  result = vim.fn.system("pkill -USR2 ghostty")
  if vim.v.shell_error == 0 then return true end

  return false
end

M.auto_export = function(theme, config)
  if not config.terminal.enabled then return end

  local emulator = config.terminal.emulator
  local emulator_config = config.terminal[emulator]

  if not emulator_config or not emulator_config.enabled then return end

  if emulator == "ghostty" then
    local success = M.write_ghostty_config(theme, emulator_config.config_path)

    if success then
      -- Silent: No notify for export

      if emulator_config.auto_reload then
        local reloaded = M.reload_ghostty()
        if not reloaded then
          vim.notify("Pantheon: Failed to reload Ghostty automatically (manual reload needed)", vim.log.levels.WARN)
        end
        -- Silent: No success notify
      end
    end
  elseif emulator == "kitty" then
    -- TODO: Implement Kitty export
    vim.notify("Pantheon: Kitty export not yet implemented", vim.log.levels.WARN)
  elseif emulator == "alacritty" then
    -- TODO: Implement Alacritty export
    vim.notify("Pantheon: Alacritty export not yet implemented", vim.log.levels.WARN)
  end
end

M.export_ghostty = function(theme_name)
  local universe, variant = require("pantheon.config").parse_theme(theme_name)
  local theme_path = "pantheon.themes." .. universe:gsub("%-", "%.") .. "." .. variant
  local ok, theme_spec = pcall(require, theme_path)

  if not ok then
    vim.notify("Failed to load theme: " .. theme_name, vim.log.levels.ERROR)
    return nil
  end

  local theme = require("pantheon.palette").create_theme(theme_spec)
  return M.export_ghostty_toml(theme)
end

M.save_ghostty = function(theme_name, output_path)
  output_path = output_path or vim.fn.expand("~/.config/ghostty/themes/pantheon.toml")

  local universe, variant = require("pantheon.config").parse_theme(theme_name)
  local theme_path = "pantheon.themes." .. universe:gsub("%-", "%.") .. "." .. variant
  local ok, theme_spec = pcall(require, theme_path)

  if not ok then
    vim.notify("Failed to load theme: " .. theme_name, vim.log.levels.ERROR)
    return
  end

  local theme = require("pantheon.palette").create_theme(theme_spec)
  local success = M.write_ghostty_config(theme, output_path)

  if success then vim.notify("Exported to: " .. output_path, vim.log.levels.INFO) end
end

M.get_palette = function(theme_name)
  local universe, variant = require("pantheon.config").parse_theme(theme_name)
  local theme_path = "pantheon.themes." .. universe:gsub("%-", "%.") .. "." .. variant
  local ok, theme_spec = pcall(require, theme_path)

  if not ok then return nil end

  local theme = require("pantheon.palette").create_theme(theme_spec)
  return {
    base16 = theme.colors,
    palette = theme.palette,
    semantic = theme.semantic,
    metadata = {
      name = theme.name,
      author = theme.author,
      description = theme.description,
    },
  }
end

M.print_palette = function(theme_name)
  local palette = M.get_palette(theme_name)
  if not palette then
    vim.notify("Failed to load theme", vim.log.levels.ERROR)
    return
  end

  print("=== " .. palette.metadata.name .. " ===")
  print("")

  if palette.palette and next(palette.palette) then
    print("--- Rich Palette ---")
    for name, color in pairs(palette.palette) do
      print(string.format("%-20s %s", name, color))
    end
    print("")
  end

  print("--- Base16 Colors ---")
  for i = 0, 15 do
    local key = i == 0 and "base00" or string.format("base%02X", i)
    if palette.base16[key] then print(string.format("%-8s %s", key, palette.base16[key])) end
  end
end

return M
